"""
Copyright (c) 2015 Red Hat, Inc
All rights reserved.

This software may be modified and distributed under the terms
of the BSD license. See the LICENSE file for details.
"""
import os
import subprocess
import tempfile
import tarfile

from atomic_reactor.plugin import PostBuildPlugin
from atomic_reactor.utils.rpm import rpm_qf_args, parse_rpm_output
from docker.errors import APIError

RPMDB_PATH = '/var/lib/rpm'
RPMDB_DIR_NAME = 'rpm'
RPMDB_PACKAGES_NAME = 'Packages'

__all__ = ('PostBuildRPMqaPlugin', )


class PostBuildRPMqaPlugin(PostBuildPlugin):
    key = "all_rpm_packages"
    is_allowed_to_fail = False
    sep = ';'

    def __init__(self, tasker, workflow, image_id, ignore_autogenerated_gpg_keys=True):
        """
        constructor

        :param tasker: ContainerTasker instance
        :param workflow: DockerBuildWorkflow instance
        """
        # call parent constructor
        super(PostBuildRPMqaPlugin, self).__init__(tasker, workflow)
        self.image_id = image_id
        self.ignore_autogenerated_gpg_keys = ignore_autogenerated_gpg_keys

        self._container_ids = []

    def run(self):
        # If another component has already filled in the image component list, skip
        if self.workflow.image_components is not None:
            return None

        if self.workflow.dockerfile_images.base_from_scratch:
            if self.workflow.conf.list_rpms_from_scratch:
                self.log.info("from scratch, list_rpms_from_scratch is True, trying get rpmdb")
                plugin_output = self.gather_output_scratch()
                if not plugin_output:
                    self.tasker.cleanup_containers(*self._container_ids)
                    return None
            else:
                self.log.info("from scratch, but list_rpms_from_scratch is False, won't run rpmqa")
                return None
        else:
            plugin_output = self.gather_output_non_scratch()

        # gpg-pubkey are autogenerated packages by rpm when you import a gpg key
        # these are of course not signed, let's ignore those by default
        if self.ignore_autogenerated_gpg_keys:
            self.log.debug("ignore rpms 'gpg-pubkey'")
            plugin_output = [x for x in plugin_output if not x.startswith("gpg-pubkey" + self.sep)]

        self.tasker.cleanup_containers(*self._container_ids)

        self.workflow.image_components = parse_rpm_output(plugin_output)

        return plugin_output

    def gather_output_non_scratch(self):
        for _ in range(5):
            container_id = self.tasker.run(
                self.image_id,
                command=rpm_qf_args(),
                create_kwargs={"entrypoint": "/bin/rpm", "user": "root"},
                start_kwargs={},
            )
            self._container_ids.append(container_id)
            self.tasker.wait(container_id)
            output = self.tasker.logs(container_id, stream=False)

            if output:
                return output

        raise RuntimeError('Unable to gather list of installed packages in container')

    def gather_output_scratch(self):
        container_dict = self.tasker.create_container(self.image_id, command=['/bin/bash'])
        container_id = container_dict['Id']
        self._container_ids.append(container_id)

        try:
            bits, _ = self.tasker.get_archive(container_id, RPMDB_PATH)
        except APIError as ex:
            self.log.info('Could not extract rpmdb in %s : %s', RPMDB_PATH, ex)
            return None
        except Exception as ex:
            self.log.info('Get archive failed while extracting rpmdb in %s : %s', RPMDB_PATH, ex)
            raise RuntimeError(ex) from ex

        with tempfile.NamedTemporaryFile() as rpmdb_archive:
            for chunk in bits:
                rpmdb_archive.write(chunk)
            rpmdb_archive.flush()
            tar_archive = tarfile.TarFile(rpmdb_archive.name)

        with tempfile.TemporaryDirectory() as rpmdb_dir:
            tar_archive.extractall(rpmdb_dir)

            rpmdb_path = os.path.join(rpmdb_dir, RPMDB_DIR_NAME)
            rpmdb_packages = os.path.join(rpmdb_path, RPMDB_PACKAGES_NAME)

            if not os.path.exists(rpmdb_packages):
                self.log.info('%s does not exist in rpmdb', RPMDB_PACKAGES_NAME)
                return None

            rpm_cmd = 'rpm --dbpath {} {}'.format(rpmdb_path, rpm_qf_args())
            try:
                self.log.info('getting rpms from rpmdb: %s', rpm_cmd)
                rpm_output = subprocess.check_output(rpm_cmd,
                                                     shell=True, universal_newlines=True)  # nosec
            except Exception as e:
                self.log.error("Failed to get rpms from rpmdb: %s", e)
                raise e

        rpm_output = [line for line in rpm_output.splitlines() if line]
        return rpm_output
